# stdlib
import hashlib
import json
import random
from os.path import dirname
from pathlib import Path
from typing import List, Optional, Tuple

# third party
import numpy as np
import pandas as pd

# dga_analysis absolute
from dga_analysis.utils.reproducibility import enable_reproducible_results

# dga_analysis relative
from .base import BaseDataset

FAMILIES = [
    "bamital_dga",
    "banjori_dga",
    "bedep_dga",
    "beebone_dga",
    "blackhole_dga",
    "bobax_dga",
    "ccleaner_dga",
    "chinad_dga",
    "chir_dga",
    "conficker_dga",
    "corebot_dga",
    "cryptolocker_dga",
    "darkshell_dga",
    "deception2_dga",
    "deception_dga",
    "diamondfox_dga",
    "dircrypt_dga",
    "dmsniff_dga",
    "dnsbenchmark_dga",
    "dnschanger_dga",
    "downloader_dga",
    "dyre_dga",
    "ebury_dga",
    "ekforward_dga",
    "emotet_dga",
    "feodo_dga",
    "fobber_dga",
    "gameover_dga",
    "gameover_p2p",
    "gozi_dga",
    "goznym_dga",
    "gspy_dga",
    "hesperbot_dga",
    "infy_dga",
    "locky_dga",
    "madmax_dga",
    "makloader_dga",
    "matsnu_dga",
    "mirai_dga",
    "modpack_dga",
    "monerominer_dga",
    "murofet_dga",
    "murofetweekly_dga",
    "mydoom_dga",
    "necurs_dga",
    "nymaim2_dga",
    "nymaim_dga",
    "oderoor_dga",
    "omexo_dga",
    "padcrypt_dga",
    "pandabanker_dga",
    "pitou_dga",
    "proslikefan_dga",
    "pushdo_dga",
    "pushdotid_dga",
    "pykspa2_dga",
    "pykspa2s_dga",
    "pykspa_dga",
    "qadars_dga",
    "qakbot_dga",
    "qhost_dga",
    "qsnatch_dga",
    "ramdo_dga",
    "ramnit_dga",
    "ranbyus_dga",
    "randomloader_dga",
    "redyms_dga",
    "rovnix_dga",
    "shifu_dga",
    "simda_dga",
    "sisron_dga",
    "sphinx_dga",
    "suppobox_dga",
    "sutra_dga",
    "symmi_dga",
    "szribi_dga",
    "tempedreve_dga",
    "tempedrevetdd_dga",
    "tinba_dga",
    "tinynuke_dga",
    "tofsee_dga",
    "torpig_dga",
    "tsifiri_dga",
    "urlzone_dga",
    "vawtrak_dga",
    "vidro_dga",
    "vidrotid_dga",
    "virut_dga",
    "volatilecedar_dga",
    "wd_dga",
    "xshellghost_dga",
    "xxhex_dga",
]

FAMILIES_BY_YEAR = {
    2007: [
        "szribi_dga",
        "torpig_dga",
        "tufik_dga",
    ],
    2008: [
        "bobax_dga",
        "conficker_dga",
    ],
    2010: [
        "bamital_dga",
        "gozi_dga",
        "murofet_dga",
    ],
    2011: [
        "darkshell_dga",
        "dnschanger_dga",
        "gameover_p2p",
        "pushdotid_dga",
        "virut_dga",
    ],
    2012: [
        "blackhole_dga",
        "feodo_dga",
        "ramnit_dga",
        "redyms_dga",
        "simda_dga",
        "sisron_dga",
        "sutra_dga",
        "ud5_dga",
    ],
    2013: [
        "banjori_dga",
        "calfbot_dga",
        "cryptolocker_dga",
        "dircrypt_dga",
        "hesperbot_dga",
        "necurs_dga",
        "oderoor_dga",
        "pushdo_dga",
        "pykspa2_dga",
        "qakbot_dga",
        "ramdo_dga",
        "suppobox_dga",
    ],
    2014: [
        "dmsniff_dga",
        "dyre_dga",
        "ekforward_dga",
        "emotet_dga",
        "gameover_dga",
        "matsnu_dga",
        "nymaim_dga",
        "symmi_dga",
        "tempedreve_dga",
        "tinba_dga",
        "urlzone_dga",
        "volatilecedar_dga",
    ],
    2015: [
        "bedep_dga",
        "beebone_dga",
        "corebot_dga",
        "diamondfox_dga",
        "fobber_dga",
        "gazavat_dga",
        "infy_dga",
        "madmax_dga",
        "ranbyus_dga",
        "rovnix_dga",
        "shifu_dga",
        "tempedrevetdd_dga",
    ],
    2016: [
        "goznym_dga",
        "grandoreiro_dga",
        "locky_dga",
        "mirai_dga",
        "modpack_dga",
        "padcrypt_dga",
        "pandabanker_dga",
        "proslikefan_dga",
        "qadars_dga",
        "randomloader_dga",
        "sphinx_dga",
        "tofsee_dga",
        "vawtrak_dga",
        "vidro_dga",
        "xxhex_dga",
    ],
    2017: [
        "ccleaner_dga",
        "wd_dga",
        "xshellghost_dga",
    ],
    2018: [
        "makloader_dga",
        "teleru_dga",
        "tinynuke_dga",
    ],
    2019: [
        "copperstealer_dga",
        "ebury_dga",
        "enviserv_dga",
        "ngioweb_dga",
        "phorpiex_dga",
        "pitou_dga",
        "qsnatch_dga",
    ],
    2020: [
        "abcbot_dga",
        "bazarloader_dga",
        "bigviktor_dga",
        "kingminer_dga",
        "necro_dga",
        "zloader_dga",
    ],
    2021: [
        "chinad_dga",
        "darkwatchman_dga",
        "kfos_dga",
        "orchard_dga",
        "pseudomanuscrypt_dga",
        "verblecon_dga",
    ],
    2022: [
        "alien_dga",
        "ares_dga",
        "flubot_dga",
        "metastealer_dga",
        "omexo_dga",
        "prometei_dga",
        "sharkbot_dga",
        "tinyfluff_dga",
        "vipersoftx_dga",
    ],
    2023: [
        "bumblebee_dga",
        "chaes_dga",
        "m0yv_dga",
    ],
}

DGA_ARITHMETIC = [
    "banjori_dga",
    "bedep_dga",
    "chinad_dga",
    "conficker_dga",
    "corebot_dga",
    "cryptolocker_dga",
    "dnschanger_dga",
    "ebury_dga",
    "emotet_dga",
    "fobber_dga",
    "gameover_dga",
    "gameover_p2p",
    "locky_dga",
    "murofet_dga",
    "murofetweekly_dga",
    "necurs_dga",
    "nymaim_dga",
    "oderoor_dga",
    "padcrypt_dga",
    "proslikefan_dga",
    "pushdo_dga",
    "pushdotid_dga",
    "pykspa2_dga",
    "pykspa2s_dga",
    "pykspa_dga",
    "qadars_dga",
    "qakbot_dga",
    "ramdo_dga",
    "ramnit_dga",
    "ranbyus_dga",
    "rovnix_dga",
    "shifu_dga",
    "simda_dga",
    "sisron_dga",
    "sphinx_dga",
    "sutra_dga",
    "symmi_dga",
    "szribi_dga",
    "tempedreve_dga",
    "tempedrevetdd_dga",
    "tinba_dga",
    "tofsee_dga",
    "torpig_dga",
    "urlzone_dga",
    "vawtrak_dga",
    "vidro_dga",
    "virut_dga",
    "xxhex_dga",
    "xshellghost_dga",
    "vidrotid_dga",
    "tsifiri_dga",
    "redyms_dga",
    "randomloader_dga",
    "qsnatch_dga",
    "qhost_dga",
    "pitou_dga",
    "mydoom_dga",
    "modpack_dga",
    "mirai_dga",
    "makloader_dga",
    "madmax_dga",
    "hesperbot_dga",
    "goznym_dga",
    "feodo_dga",
    "downloader_dga",
    "dnsbenchmark_dga",
    "dmsniff_dga",
    "dircrypt_dga",
    "beebone_dga",
    "diamondfox_dga",
    "darkshell_dga",
    "ccleaner_dga",
    "bobax_dga",
    "blackhole_dga",
]
DGA_HASH = [  # Hash DGA
    "bamital_dga",
    "dyre_dga",
    "ekforward_dga",
    "infy_dga",
    "pandabanker_dga",
    "tinynuke_dga",
    "wd_dga",
    "omexo_dga",
    "monerominer_dga",
    "gspy_dga",
    "chir_dga",
]
DGA_WORDLIST = [  # Wordlist DGA
    "gozi_dga",
    "matsnu_dga",
    "nymaim2_dga",
    "suppobox_dga",
]

DGA_PERM = [  # Permutation DGA
    "volatilecedar_dga",
]


class DatasetDGArchive(BaseDataset):
    def __init__(
        self,
        sample_size: Optional[int] = None,
        max_source_size: int = 1000,
        shuffle: bool = True,
        families: List[str] = FAMILIES,
        filter_by_years: Optional[list] = None,
        random_state=0,
        workspace=Path(dirname(__file__)),
        dataset_timestamp: Optional[str] = None,  # "YYYY-MM-DD", "YYYY_MM_DD"
    ):
        self.sample_size = sample_size
        self.max_source_size = max_source_size
        self.shuffle = shuffle
        self.families = families
        self.dataset_timestamp = dataset_timestamp

        if filter_by_years is not None:
            new_families = []
            for year in filter_by_years:
                if year not in FAMILIES_BY_YEAR:
                    continue
                new_families.extend(FAMILIES_BY_YEAR[year])
            self.families = new_families

        self.random_state = random_state
        enable_reproducible_results(random_state)

        super().__init__(workspace=workspace)

    def _load_from_timestamp(self) -> "DatasetDGArchive":
        data_path = self.workspace / ".data/dgarchive_by_day"
        timestamp = self.dataset_timestamp.replace("-", "_")
        path = data_path / f"dgarchive_{timestamp}.json"

        print(path)
        if not path.exists():
            raise ValueError(f"Path not found {path}")

        with open(path) as f:
            raw_data = json.load(f)
        enable_reproducible_results(self.random_state)

        self.raw_data = []
        self.raw_labels = []

        for family_key in raw_data:
            family = family_key.split("_")[:2]
            family = "_".join(family)
            if family not in self.families:
                continue
            dga_domains = pd.Series(raw_data[family_key])
            dga_domains = dga_domains.sample(
                min(self.max_source_size, len(dga_domains)),
                random_state=self.random_state,
            )
            self.raw_data.extend(dga_domains.values)
            self.raw_labels.extend([family] * len(dga_domains))

        return self

    def _load_archive(self) -> "DatasetDGArchive":
        data_path = self.workspace / ".data/dgarchive"
        enable_reproducible_results(self.random_state)

        self.raw_data = []
        self.raw_labels = []

        cache_families = "_".join(self.families)
        cache_families = hashlib.md5(cache_families.encode("utf-8")).hexdigest()

        cache_path = (
            data_path
            / f"grouped_dgarchive_max{self.max_source_size}_scnt{self.sample_size}_sh{self.shuffle}_fams{cache_families}.csv"
        )

        if cache_path.exists():
            cache = pd.read_csv(cache_path)
        else:
            samples = set(data_path.glob("*.csv")) - set(
                data_path.glob("grouped_*.csv")
            )
            for sample_path in samples:
                label = sample_path.stem
                print(label, self.families)
                if label not in self.families:
                    continue
                dga_domains = pd.read_csv(sample_path)
                dga_domains = dga_domains.sample(
                    min(self.max_source_size, len(dga_domains)),
                    random_state=self.random_state,
                )
                self.raw_data.extend(dga_domains.values[:, 0])
                self.raw_labels.extend([label] * len(dga_domains))

            cache = pd.DataFrame({"domain": self.raw_data, "label": self.raw_labels})
            cache.to_csv(cache_path, index=False)

        self.raw_data = cache["domain"].values.tolist()
        self.raw_labels = cache["label"].values.tolist()

        return self

    def _load(self) -> "DatasetDGArchive":
        if self.dataset_timestamp is not None:
            self._load_from_timestamp()
        else:
            self._load_archive()

        filtered_indexes = [
            idx for idx, family in enumerate(self.raw_labels) if family in self.families
        ]

        self.raw_data = np.asarray(self.raw_data)[filtered_indexes].tolist()
        self.raw_labels = np.asarray(self.raw_labels)[filtered_indexes].tolist()

        if self.shuffle:
            indexes = list(range(len(self.raw_data)))
            random.shuffle(indexes)
            self.raw_data = np.asarray(self.raw_data)[indexes].tolist()
            self.raw_labels = np.asarray(self.raw_labels)[indexes].tolist()

        return self

    def raw(
        self, only_2ld: bool = False, remove_duplicates: bool = False
    ) -> Tuple[List, List]:
        if self.sample_size is not None:
            return self._drop_duplicates(
                [
                    self.get_2ld(x) if only_2ld else x
                    for x in self.raw_data[: self.sample_size]
                ],
                self.raw_labels[: self.sample_size],
                remove_duplicates=remove_duplicates,
            )

        return self._drop_duplicates(
            [self.get_2ld(x) if only_2ld else x for x in self.raw_data],
            self.raw_labels,
            remove_duplicates=remove_duplicates,
        )
