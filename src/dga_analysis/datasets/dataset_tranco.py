# stdlib
import math
import random
import re
from os.path import dirname
from pathlib import Path
from random import shuffle
from typing import List, Optional, Tuple

# third party
import numpy as np
from ail_typo_squatting import (
    addition,
    changeOrder,
    commonMisspelling,
    doubleReplacement,
    homoglyph,
    homophones,
    omission,
    repetition,
    replacement,
)
from tranco import Tranco

# dga_analysis relative
from .base import BaseDataset

TYPOS = [
    "addition",
    "doubleReplacement",
    "homoglyph",
    "omission",
    "repetition",
    "replacement",
    "change_order",
    "bitsquat",
]


class DatasetTranco(BaseDataset):
    def __init__(
        self,
        sample_size: Optional[int] = None,
        shuffle: bool = True,
        typos: List = [],
        workspace=Path(dirname(__file__)),
        dataset_timestamp: str = "2024-03-01",
    ):
        self.sample_size = sample_size
        self.shuffle = shuffle
        self.dataset_timestamp = dataset_timestamp
        self.typos = typos

        super().__init__()

    def _load(self) -> "DatasetTranco":
        data_path = self.workspace / ".data/tranco"
        t = Tranco(cache=True, cache_dir=data_path)
        self.raw_data = t.list(date=self.dataset_timestamp)

        return self

    def _generate_bitsquat_domain(self, full_domain):
        domain = self.get_2ld(full_domain)
        bitsquat_domains = []

        for i in range(len(domain) * 8):
            bit_flipped_domain = list(domain)
            byte_index = i // 8
            bit_index = i % 8

            byte = ord(bit_flipped_domain[byte_index])
            byte ^= 1 << bit_index

            bit_flipped_domain[byte_index] = chr(byte)
            if i == 0:
                regex = r"[a-zA-Z0-9]"
            else:
                regex = r"[a-zA-Z0-9\-\_]"

            out_str = "".join(bit_flipped_domain)
            if re.match(regex, out_str):
                bitsquat_domains.append(out_str)

        out_domains = []
        for bitdomain in bitsquat_domains:
            out_domains.append(full_domain.replace(domain, bitdomain))

        return out_domains

    def _generate_typos(self, domains, limit: int = 5):
        if len(self.typos) == 0:
            return domains

        output = []
        for domain in domains:
            for typo in self.typos:
                resultList = []
                if typo == "addition":
                    resultList = addition(
                        domain=domain,
                        resultList=resultList,
                        verbose=False,
                        limit=math.inf,
                        givevariations=False,
                        keeporiginal=False,
                    )
                elif typo == "commonMisspelling":
                    resultList = commonMisspelling(
                        domain=domain,
                        resultList=resultList,
                        verbose=False,
                        limit=math.inf,
                        givevariations=False,
                        keeporiginal=False,
                    )
                elif typo == "doubleReplacement":
                    resultList = doubleReplacement(
                        domain=domain,
                        resultList=resultList,
                        verbose=False,
                        limit=math.inf,
                        givevariations=False,
                        keeporiginal=False,
                    )
                elif typo == "homoglyph":
                    resultList = homoglyph(
                        domain=domain,
                        resultList=resultList,
                        verbose=False,
                        limit=math.inf,
                        givevariations=False,
                        keeporiginal=False,
                    )
                elif typo == "homophones":
                    resultList = homophones(
                        domain=domain,
                        resultList=resultList,
                        verbose=False,
                        limit=math.inf,
                        givevariations=False,
                        keeporiginal=False,
                    )
                elif typo == "omission":
                    resultList = omission(
                        domain=domain,
                        resultList=resultList,
                        verbose=False,
                        limit=math.inf,
                        givevariations=False,
                        keeporiginal=False,
                    )
                elif typo == "repetition":
                    resultList = repetition(
                        domain=domain,
                        resultList=resultList,
                        verbose=False,
                        limit=math.inf,
                        givevariations=False,
                        keeporiginal=False,
                    )
                elif typo == "replacement":
                    resultList = replacement(
                        domain=domain,
                        resultList=resultList,
                        verbose=False,
                        limit=math.inf,
                        givevariations=False,
                        keeporiginal=False,
                    )
                elif typo == "change_order":
                    resultList = changeOrder(
                        domain=domain,
                        resultList=resultList,
                        verbose=False,
                        limit=math.inf,
                        givevariations=False,
                        keeporiginal=False,
                    )
                elif typo == "bitsquat":
                    resultList = self._generate_bitsquat_domain(domain)
                else:
                    raise RuntimeError(typo)
                shuffle(resultList)
                resultList = resultList[:limit]
                output.extend(resultList)
        return output

    def raw(
        self, only_2ld: bool = False, remove_duplicates: bool = False
    ) -> Tuple[List, List]:
        random.seed(0)

        if self.sample_size is not None:
            domains = self.raw_data.top(self.sample_size)
            domains = self._generate_typos(domains)

            if self.shuffle:
                random.shuffle(domains)

            return self._drop_duplicates(
                [self.get_2ld(x) if only_2ld else x for x in domains],
                np.zeros(len(domains)),
                remove_duplicates=remove_duplicates,
            )

        domains = self.raw_data.top()
        domains = self._generate_typos(domains)

        if self.shuffle:
            random.shuffle(domains)

        return self._drop_duplicates(
            [self.get_2ld(x) if only_2ld else x for x in domains],
            np.zeros(len(domains)),
            remove_duplicates=remove_duplicates,
        )
