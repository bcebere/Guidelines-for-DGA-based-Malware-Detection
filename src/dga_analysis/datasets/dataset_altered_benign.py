# stdlib
import random
from os.path import dirname
from pathlib import Path
from typing import List, Tuple

# third party
import tldextract

# dga_analysis absolute
from dga_analysis.utils.reproducibility import enable_reproducible_results

# dga_analysis relative
from .base import BaseDataset
from .dataset_alexa import DatasetAlexa
from .dataset_cisco import DatasetCisco
from .dataset_tranco import DatasetTranco

STRATEGIES = [
    "permutation",
    "alter_char",
    "reverse",
]


class DatasetAltered(BaseDataset):
    def __init__(
        self,
        sample_size: int,
        strategy: str = "permutation",  # permutation, alter_char, reverse
        source: str = "tranco",
        shuffle: bool = True,
        workspace=Path(dirname(__file__)),
    ):
        assert source in [
            "tranco",
            "alexa",
            "cisco",
        ], f"Unsupported root dataset {source}"
        assert strategy in STRATEGIES, f"Unsupported strategy {strategy}"
        self.sample_size = sample_size
        self.source = source
        self.shuffle = shuffle
        self.strategy = strategy
        enable_reproducible_results(0)

        super().__init__(workspace=workspace)

    def _load_root_benign(self):
        fail_off = 1000
        if self.source == "tranco":
            local_dataset = DatasetTranco(
                sample_size=self.sample_size + fail_off,
                shuffle=self.shuffle,
                workspace=self.workspace,
            )
        elif self.source == "cisco":
            local_dataset = DatasetCisco(
                sample_size=self.sample_size + fail_off,
                shuffle=self.shuffle,
                workspace=self.workspace,
            )
        elif self.source == "alexa":
            local_dataset = DatasetAlexa(
                sample_size=self.sample_size + fail_off,
                shuffle=self.shuffle,
                workspace=self.workspace,
            )
        else:
            raise ValueError(f"unknown source {self.source}")

        return local_dataset.raw()

    def _flip_char(self, string: str) -> str:
        if string == "":
            return string
        replacement_chars = "abcdefghijklmnopqrstuvwxyz"

        ref_idx = random.randrange(0, len(string))
        new_idx = random.randrange(0, len(replacement_chars))
        return string.replace(string[ref_idx], replacement_chars[new_idx])

    def _shuffle_str(self, string: str) -> str:
        if string == "":
            return string
        chars = list(string)
        random.shuffle(chars)
        return "".join(chars)

    def _reverse(self, string: str) -> str:
        if string == "":
            return string

        return string[::-1]

    def _alter_root_data(self, data: list):
        new_data = []
        for ref_domain in data:
            tokens = tldextract.extract(ref_domain)
            suff = tokens.suffix
            if self.strategy == "permutation":
                sub = self._shuffle_str(tokens.subdomain)
                dom = self._shuffle_str(tokens.domain)
            elif self.strategy == "alter_char":
                sub = self._flip_char(tokens.subdomain)
                dom = self._flip_char(tokens.domain)
            elif self.strategy == "reverse":
                sub = self._reverse(tokens.subdomain)
                dom = self._reverse(tokens.domain)
            else:
                raise NotImplementedError(f"unknown strategy {self.strategy}")

            new_domain = f"{dom}.{suff}"
            if sub != "":
                new_domain = f"{sub}.{new_domain}"

            if new_domain != ref_domain:
                new_data.append(new_domain)

        return new_data

    def _load(self) -> "DatasetAltered":
        root_data, _ = self._load_root_benign()
        self.raw_data = self._alter_root_data(root_data)
        self.raw_labels = [f"{self.strategy}_dga"] * len(self.raw_data)

        return self

    def raw(self, only_2ld: bool = False, remove_duplicates: bool = False) -> Tuple[List, List]:
        if self.sample_size is not None:
            return self._drop_duplicates(
                [
                    self.get_2ld(x) if only_2ld else x
                    for x in self.raw_data[: self.sample_size]
                ],
                self.raw_labels[: self.sample_size],
                remove_duplicates=remove_duplicates
            )

        return self._drop_duplicates([
            self.get_2ld(x) if only_2ld else x for x in self.raw_data
        ], self.raw_labels,
            remove_duplicates=remove_duplicates)
