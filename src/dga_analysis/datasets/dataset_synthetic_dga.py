# stdlib
import hashlib
import json
import random
import re
import time
from ctypes import c_uint
from datetime import datetime
from os.path import dirname
from pathlib import Path
from typing import List, Optional, Tuple

# third party
import numpy as np
import pandas as pd
import pytz
from pytrends.request import TrendReq

# dga_analysis absolute
from dga_analysis.utils.reproducibility import enable_reproducible_results

# dga_analysis relative
from .base import BaseDataset
from .dataset_tranco import DatasetTranco

FAMILIES = [
    "AppendAttack",
    "CharBot",
    "DeepDGA",
    "MaskDGA",
    "RandomAttack",
    "SearchAttack",
    "DictSuppoboxTranco",
    "DictSuppoboxEnglish",
    "DictMatsnu",
    "DictGoziTranco",
    "DictGoziEnglish",
    "DictGTrends",
    "Khaos",
]


class DatasetSyntheticDGA(BaseDataset):
    def __init__(
        self,
        sample_size: Optional[int] = None,
        max_source_size: int = 100000,
        shuffle: bool = True,
        families: List[str] = FAMILIES,
        random_state=0,
        workspace=Path(dirname(__file__)),
    ):
        self.sample_size = sample_size
        self.max_source_size = max_source_size
        self.shuffle = shuffle
        self.families = families
        enable_reproducible_results(random_state)

        super().__init__(workspace=workspace)

    def _load(self) -> "DatasetSyntheticDGA":
        data_path = self.workspace / ".data/Adversarial-DGA-Datasets"
        random.seed(0)

        self.raw_data = []
        self.raw_labels = []

        cache_families = "_".join(self.families)
        cache_families = hashlib.md5(cache_families.encode("utf-8")).hexdigest()

        cache_path = (
            data_path
            / f"grouped_syntheticdga_max{self.max_source_size}_scnt{self.sample_size}_sh{self.shuffle}_fams{cache_families}.csv"
        )

        if cache_path.exists():
            cache = pd.read_csv(cache_path)
        else:
            for family in self.families:
                label = family
                if family == "AppendAttack":
                    samples = pd.read_csv(data_path / family / "advTrain_sub-cnn.csv")
                    samples = samples["url"].str.strip()
                elif family == "CharBot":
                    samples = pd.read_csv(data_path / family / "advTrain.csv")
                    samples = samples["url"].str.strip()
                elif family == "DeepDGA":
                    samples = pd.read_csv(data_path / family / "advTrain.csv")
                    samples = samples["domain"].str.strip()
                elif family == "MaskDGA":
                    samples = pd.read_csv(
                        data_path / family / "advTrain_sub-cnn_prec-75.csv"
                    )
                    samples = samples["url"].str.strip()
                elif family == "RandomAttack":
                    samples = pd.read_csv(data_path / family / "advTrain.csv")
                    samples = samples["url"].str.strip()
                elif family == "SearchAttack":
                    samples = pd.read_csv(data_path / family / "advTrain_sub-cnn.csv")
                    samples = samples["url"].str.strip()
                elif family == "DictSuppoboxTranco":
                    wordlist, _ = DatasetTranco(sample_size=self.sample_size).raw(
                        only_2ld=True
                    )
                    samples = self._suppobox_generate_n(
                        wordlist=wordlist, n=self.sample_size
                    )
                    samples = pd.Series(samples)
                elif family == "DictSuppoboxEnglish":
                    with open(self.workspace / ".data/wordlist_3esl.txt", "r") as f:
                        wordlist = [
                            line.rstrip()
                            for line in f
                            if re.match(r"^[a-zA-Z0-9_-]+$", line.rstrip())
                        ]
                    assert len(wordlist) > 0, "SuppoboxEnglish wordlist is empty"
                    samples = self._suppobox_generate_n(
                        wordlist=wordlist, n=self.sample_size
                    )
                    samples = pd.Series(samples)
                elif family == "DictMatsnu":
                    with open(self.workspace / ".data/wordlist_dict.json", "r") as f:
                        dictionary = json.load(f)
                    samples = self._matsnu_generate_n(
                        dictionary=dictionary, n=self.sample_size
                    )
                    samples = pd.Series(samples)
                elif family == "DictGoziTranco":
                    wordlist, _ = DatasetTranco(sample_size=self.sample_size).raw(
                        only_2ld=True
                    )
                    samples = self._gozi_generate_n(
                        wordlist=wordlist, n=self.sample_size
                    )
                    samples = pd.Series(samples)
                elif family == "DictGoziEnglish":
                    with open(self.workspace / ".data/wordlist_3esl.txt", "r") as f:
                        wordlist = [
                            line.rstrip()
                            for line in f
                            if re.match(r"^[a-zA-Z0-9_-]+$", line.rstrip())
                        ]
                    samples = self._gozi_generate_n(
                        wordlist=wordlist, n=self.sample_size
                    )
                    samples = pd.Series(samples)
                elif family == "DictGTrends":
                    with open(self.workspace / ".data/wordlist_dict.json", "r") as f:
                        dictionary = json.load(f)
                    samples = self._gtrends_generate_n(
                        dictionary=dictionary, n=self.sample_size
                    )
                    samples = pd.Series(samples)
                elif family == "Khaos":
                    data = pd.read_csv(self.workspace / ".data/khaos_dataset.csv")
                    samples = pd.Series(data["SLD"].values)
                else:
                    raise RuntimeError(f"unknown family {family}")

                dga_domains = samples.sample(
                    min(self.max_source_size, len(samples)), random_state=0
                )
                self.raw_data.extend(dga_domains.values)
                self.raw_labels.extend([label] * len(dga_domains))

                cache = pd.DataFrame(
                    {"domain": self.raw_data, "label": self.raw_labels}
                )
                cache.to_csv(cache_path, index=False)

        self.raw_data = cache["domain"].values.tolist()
        self.raw_labels = cache["label"].values.tolist()

        filtered_indexes = [
            idx for idx, family in enumerate(self.raw_labels) if family in self.families
        ]

        self.raw_data = np.asarray(self.raw_data)[filtered_indexes].tolist()
        self.raw_labels = np.asarray(self.raw_labels)[filtered_indexes].tolist()

        if self.shuffle:
            indexes = list(range(len(self.raw_data)))
            random.shuffle(indexes)
            self.raw_data = np.asarray(self.raw_data)[indexes].tolist()
            self.raw_labels = np.asarray(self.raw_labels)[indexes].tolist()

        return self

    def raw(
        self, only_2ld: bool = False, remove_duplicates: bool = False
    ) -> Tuple[List, List]:
        if self.sample_size is not None:
            return self._drop_duplicates(
                [
                    self.get_2ld(x) if only_2ld else x
                    for x in self.raw_data[: self.sample_size]
                ],
                self.raw_labels[: self.sample_size],
                remove_duplicates=remove_duplicates,
            )

        return self._drop_duplicates(
            [self.get_2ld(x) if only_2ld else x for x in self.raw_data],
            self.raw_labels,
            remove_duplicates=remove_duplicates,
        )

    def _gtrends_generate_n(self, dictionary, n=1000):
        gtrends = Gtrends(dictionary)
        domains = [
            gtrends.generate_domain(int(gtrends.google_trends(i), base=16))
            for i in range(n)
        ]

        return domains

    def _suppobox_generate_n(self, wordlist, n=1000):
        domains = self._suppobox(wordlist, samples=n)
        return domains

    def _matsnu_generate_n(self, dictionary, n=1000):
        matsnu = Matsnu(dictionary)
        domains = [matsnu.generate_domain() for _ in range(n)]
        return domains

    def _gozi_generate_n(self, wordlist, n=1000):
        domains = self._gozi(datetime.now(), wordlist, n)
        return domains

    """
    Suppobox
    source: https://github.com/baderj/domain_generation_algorithms/tree/master/suppobox
    license: GPL-2.0
    """

    def _suppobox(self, words, time_=time.time(), samples=1000) -> list[str]:
        domains = []

        seed = int(time_) >> 9
        for c in range(samples):
            nr = seed
            res = 16 * [0]
            shuffle = [3, 9, 13, 6, 2, 4, 11, 7, 14, 1, 10, 5, 8, 12, 0]
            for i in range(15):
                res[shuffle[i]] = nr % 2
                nr = nr >> 1

            first_word_index = 0
            for i in range(7):
                first_word_index <<= 1
                first_word_index ^= res[i]

            second_word_index = 0
            for i in range(7, 15):
                second_word_index <<= 1
                second_word_index ^= res[i]
            second_word_index += 0x80

            first_word = words[first_word_index % len(words)]
            second_word = words[second_word_index % len(words)]
            tld = ""  # ".net"
            domains.append("{}{}{}".format(first_word, second_word, tld))
            seed += 1

        return domains

    """
    Gozi
    source: https://github.com/baderj/domain_generation_algorithms/tree/master/gozi
    license: GPL-2.0
    """

    def _gozi(self, date, words, n=1000):
        diff = date - datetime.strptime("2015-01-01", "%Y-%m-%d")
        days_passed = diff.days // random.randint(3, 5)
        flag = 1
        seed = (flag << 16) + days_passed - 306607824
        r = Rand(seed)

        domains = []

        for i in range(n):
            r.rand()
            v = r.rand()
            length = v % 12 + 12
            domain = ""
            while len(domain) < length:
                v = r.rand() % len(words)
                word = words[v]
                length = len(word)
                if not r.rand() % 3:
                    length >>= 1
                if len(domain) + length <= 24:
                    domain += word[:length]
            # domain += '.com'
            domains.append(domain)
        return domains


"""
Matsnu
source: https://github.com/andrewaeva/DGA/blob/master/dga_algorithms/Matsnu.py
license: GPL-2.0
"""


class Matsnu:
    def __init__(self, dictionary):
        self.verbs = dictionary["verb"]
        self.nouns = dictionary["noun"]

        self.domain_seed = 0xDEAD
        self.next_domain = 1
        self.const1 = 0xDEAD
        self.const2 = 0xBEEF

    def _get_date(self):
        dt = str(datetime.now()).split(" ")[0]
        dstash = dt.split("-")
        dd = dstash[2]
        mm = dstash[1]
        yyyy = dstash[0]
        return int(dd), int(mm), int(yyyy)

    def _choose_word(self, word_list):
        # time = get_date()[0]
        time = random.randint(1, 10000)
        domain_seed = (
            (
                (
                    (
                        (
                            (
                                (
                                    (
                                        ((self.domain_seed & 0xFFFF) * self.const1)
                                        & 0xFFFF
                                    )
                                    * time
                                )
                                & 0xFFFF
                            )
                            * self.const2
                        )
                        & 0xFFFF
                    )
                    * self.next_domain
                )
                & 0xFFFF
            )
            ^ self.const1
        ) & 0xFFFF
        rem = domain_seed % len(word_list)
        self.next_domain += 1
        return word_list[rem]

    def generate_domain(self):
        domain = ""
        start_flag = 0
        while len(domain) < 24:
            if start_flag == 0:
                domain += self._choose_word(self.verbs)
                start_flag = 1
            domain += self._choose_word(self.nouns)
        # domain += '.com'
        return domain


"""
Gtrends
source: https://github.com/d-Raco/gtrends-dga/tree/main
license: GPL-3.0
"""


class Gtrends:
    def __init__(self, dictionary):
        self.seed = "0a5d7b1f194820e1377d9348ff98"
        self.dictionary = dictionary
        pytrend = TrendReq()
        self.trends = pytrend.trending_searches()

    def generate_index(self, today, mod):
        string = self.seed + str(
            today.year + today.month + today.day + today.hour + mod
        )
        hash = hashlib.md5(string.encode()).hexdigest()

        return hash

    def google_trends(self, mod):
        today = datetime.now(pytz.utc)

        df = self.trends

        trend = df[0][int(self.generate_index(today, mod), base=16) % df.size] + str(
            today.year + today.month + today.day + today.hour + mod
        )

        hash = hashlib.md5(trend.encode()).hexdigest()

        return hash

    def generate_domain(self, num):
        domain = ""

        for domain_component in ["adjective", "separator", "noun"]:  # , 'tld']:
            dd = self.dictionary[domain_component]
            domain += dd[num % len(dd)]

        return domain


"""
Helper class for Gozi
"""


class Rand:
    def __init__(self, seed):
        self.r = c_uint(seed)

    def rand(self):
        self.r.value = 1664525 * self.r.value + 1013904223
        return self.r.value
