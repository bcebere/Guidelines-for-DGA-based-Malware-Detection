# stdlib
from typing import Any, List, Optional, Tuple

# third party
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler

# dga_analysis absolute
from dga_analysis.common.mlp import MLP
from dga_analysis.utils.constants import DEVICE
from dga_analysis.utils.reproducibility import enable_reproducible_results

# dga_analysis relative
from .base import BaseDetector


class NeuralNetClassifier(BaseDetector):
    def __init__(
        self,
        n_layers_hidden: int = 1,
        n_units_hidden: int = 300,
        nonlin: str = "relu",
        nonlin_out: Optional[List[Tuple[str, int]]] = None,
        lr: float = 1e-3,
        weight_decay: float = 1e-3,
        opt_betas: tuple = (0.9, 0.999),
        n_iter: int = 500,
        batch_size: int = 500,
        n_iter_print: int = 10,
        random_state: int = 0,
        patience: int = 10,
        n_iter_min: int = 100,
        dropout: float = 0.1,
        clipping_value: int = 1,
        early_stopping: bool = True,
        residual: bool = False,
        device: Any = DEVICE,
        dataloader_sampler: Any = None,
    ) -> None:

        enable_reproducible_results(random_state)

        self.n_layers_hidden = n_layers_hidden
        self.n_units_hidden = n_units_hidden
        self.nonlin = nonlin
        self.nonlin_out = nonlin_out
        self.lr = lr
        self.weight_decay = weight_decay
        self.opt_betas = opt_betas
        self.n_iter = n_iter
        self.batch_size = batch_size
        self.n_iter_print = n_iter_print
        self.patience = patience
        self.n_iter_min = n_iter_min
        self.dropout = dropout
        self.clipping_value = clipping_value
        self.device = device
        self.random_state = random_state
        self.residual = residual
        self.dataloader_sampler = dataloader_sampler
        self.early_stopping = early_stopping

    def fit(self, X: np.ndarray, y: np.ndarray) -> "NeuralNetClassifier":
        X = np.asarray(X)
        y = np.asarray(y)

        self.model = MLP(
            n_units_in=X.shape[-1],
            n_units_out=len(np.unique(y)),
            task_type="classification",
            n_layers_hidden=self.n_layers_hidden,
            n_units_hidden=self.n_units_hidden,
            nonlin=self.nonlin,
            nonlin_out=self.nonlin_out,
            lr=self.lr,
            weight_decay=self.weight_decay,
            opt_betas=self.opt_betas,
            n_iter=self.n_iter,
            batch_size=self.batch_size,
            n_iter_print=self.n_iter_print,
            random_state=self.random_state,
            patience=self.patience,
            n_iter_min=self.n_iter_min,
            dropout=self.dropout,
            clipping_value=self.clipping_value,
            early_stopping=self.early_stopping,
            residual=self.residual,
            device=self.device,
            dataloader_sampler=self.dataloader_sampler,
        )

        self.scaler = MinMaxScaler().fit(X)
        X = self.scaler.transform(X)

        self.model.fit(X, y)
        return self

    def predict(self, X: pd.DataFrame) -> pd.DataFrame:
        X = np.asarray(X)
        X = self.scaler.transform(X)
        return self.model.predict(X)

    def predict_proba(self, X: pd.DataFrame) -> pd.DataFrame:
        X = np.asarray(X)
        X = self.scaler.transform(X)
        return self.model.predict_proba(X)

    @staticmethod
    def name() -> str:
        return "nn"
