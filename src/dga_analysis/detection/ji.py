# stdlib
from typing import Any

# third party
import numpy as np
import pandas as pd
from nltk import ngrams

# dga_analysis relative
from .base import BaseDetector


def _extract_bigrams(domains: list) -> list:
    # extract second level domains
    domains = [x[0] for x in domains]
    domains = [x if "." not in x else x.strip().split(".")[-2] for x in domains]

    # extract bigrams from the second level domains
    bigrams = [
        [first + second for first, second in ngrams(sample, 2)]
        + [""] * (24 - len(sample))
        for sample in domains
    ]

    return bigrams


class JIClassifier(BaseDetector):
    def __init__(
        self,
        benign: int = 0,
        malicious: int = 1,
    ) -> None:
        self.model = None
        self.benign = benign
        self.malicious = malicious

    def fit(self, X: pd.DataFrame, y: pd.Series) -> "JIClassifier":
        """
        Train by storing samples of bigrams of benign domains each with a max length of 24
        """

        bigrams = _extract_bigrams(
            [
                sample
                for sample, label in zip(np.asarray(X), np.asarray(y))
                if label == self.benign
            ]
        )

        self.model = bigrams

        return self

    def predict(self, X, *args: Any, **kwargs: Any) -> np.ndarray:
        """
        Output whether the sample is close enough to the benign samples to count as benign
        """
        probabilities = self.predict_proba(X)
        return np.argmax(probabilities, -1).squeeze()

    def predict_proba(self, X: pd.DataFrame, *args: Any, **kwargs: Any) -> np.ndarray:
        """
        Output the probabilities that the samples are benign
        """
        X_bigrams = _extract_bigrams(np.asarray(X))

        jaccard_indices = []

        for x in X_bigrams:
            curr = []
            for a in self.model:
                set_x = set(x)
                set_a = set(a)
                x_and_a = len(set_x & set_a)

                if x_and_a >= (
                    0.75 * len(set_x)
                ):  # only JI of benign words that contain 75% of the sample's bigrams
                    curr.append(
                        1 - x_and_a / len(set_x | set_a)
                    )  # JI of sample and benign word
            jaccard_indices.append(curr)

        #        jaccard_indices = [
        #            [
        #                1 - len(set(x) & set(a)) / len(set(x) | set(a))  # JI of sample and benign word
        #                for a in self.model
        #                if len(set(x) & set(a)) >= (0.75 * len(set(x)))
        #                # only JI of benign words that contain 75% of the sample's bigrams
        #            ] for x in X_bigrams
        #        ]

        probabilities_benign = [
            0 if len(x) == 0 else sum(x) / len(x)  # average of JIs
            for x in jaccard_indices
        ]

        probabilities_malicious = [1 - x for x in probabilities_benign]

        return pd.DataFrame(
            data={
                self.benign: probabilities_benign,
                self.malicious: probabilities_malicious,
            }
        ).values

    @staticmethod
    def name() -> str:
        return "jaccard_index"
