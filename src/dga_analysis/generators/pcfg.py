# stdlib
from typing import Any, Optional

# third party
import numpy as np
import random
import re

# dga_analysis absolute
from dga_analysis.utils.features.hyphenate import hyphenate_word

# dga_analysis relative
from .base import BaseGenerator

# patterns for filtering out domain names that shouldn't be produced
_re_ip_pattern = '\d{1,3}-\d{1,3}-\d{1,3}-\d{1,3}'
_re_prefixes = [
    '', 'ip-', 'iptv-', 'dsl-', 'ti-', 'host-', 'host', 'ull',
    'ntl-', 'link-', 'OL-', 'ss-', 'dhcp-', 'dhcp', 'sl-', 'i-d-', 'user-', 'dyn-', 'static-',
    'adsl-', 'ppp-', 'softbank-', 'Dinamico-', '-ipbfp-', 'AWBLnew-', 'ip', '0xX', 'client-'
]
_re_patterns = [re.compile('^' + prefix + _re_ip_pattern + '$') for prefix in _re_prefixes]
_re_patterns.extend([re.compile('^' + prefix + '\d$') for prefix in _re_prefixes])
_re_patterns.append(re.compile('^nx--'))  # filter out domains with special characters


def _pcfg_get_subsets(syllables: list[str]) -> (list[str], list[str]):
    random.shuffle(syllables)
    i = random.randint(1, len(syllables) - 1)
    return syllables[:i], syllables[i:]


def _domain_filter(domain: str) -> bool:
    for pattern in _re_patterns:
        if pattern.match(domain):
            return True
    return False


class PCFGGenerator(BaseGenerator):
    def __init__(
            self,
            data_type: str = "domain",  # "domain" or "dictionary"
            include_nums: bool = False,
            p_num_in_ip: float = 0.567,  # currently unused
    ) -> None:
        super().__init__()

        self.data_type = data_type
        self.include_nums = include_nums
        self.p_num_in_ip = p_num_in_ip
        self.a = []
        self.c = []
        self.ip_list_1 = set()
        self.ip_list_3 = set()

    # PCFG
    # S -> BB
    # B -> aBc (p=0.25)
    # B -> âˆ… (p=0.75)
    def _pcfg_get_word(self) -> str:
        word = self._pcfg_b(self.a, self.c) + self._pcfg_b(self.a, self.c)
        while word.strip() == '':
            word = self._pcfg_b(self.a, self.c) + self._pcfg_b(self.a, self.c)
        return word

    def _pcfg_b(self, a: list[str], c: list[str]) -> str:
        if random.random() < 0.75:
            return ''
        else:
            return random.choice(a) + self._pcfg_b(a, c) + random.choice(c)

    def fit(self, X: Optional[np.ndarray] = None) -> "PCFGGenerator":
        if type(X) == np.ndarray:
            X = X.tolist()

        syllables = list()

        if self.data_type == "domain":
            for x in X:
                for second_level_domain in x.strip().split('.')[-2]:
                    if not _domain_filter(second_level_domain):
                        syllables.extend(hyphenate_word(second_level_domain))
                        #if self.include_nums:
                        #    [[self.ip_list_1.add(h) for h in hyphenate_word(a)] for a in
                        #     re.findall(r'[a-zA-Z]+', second_level_domain)]
                        #    [self.ip_list_3.add(a) for a in re.findall(r'\d+', second_level_domain)]
                        #    [self.ip_list_3.add(a + '-') for a in re.findall(r'\d+', second_level_domain)]
                        #    [self.ip_list_3.add('-' + a) for a in re.findall(r'\d+', second_level_domain)]
        else:
            for x in X:
                syllables.extend(hyphenate_word(x))

        if self.include_nums:
            syllables.extend([str(i) for i in range(2001) for _ in range(20)])

        self.a, self.c = _pcfg_get_subsets(syllables)

        return self

    def generate(self, n_samples: int) -> np.ndarray:
        domains = [self._pcfg_get_word() for _ in range(n_samples)]

        return np.asarray(domains)

    @staticmethod
    def name() -> str:
        return "pcfg"
